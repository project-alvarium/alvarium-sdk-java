/*******************************************************************************
 * Copyright 2023 Dell Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/

package com.alvarium.annotators.vulnerability;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;


public class GoModHandler implements PackageFileHandler {
    final private File file;

    protected GoModHandler(String dir) {
        this.file = new File(dir + "/" + "go.mod");
    }

    @Override
    public String getFileName() {
        return this.file.getName();
    }

    @Override
    public Map<String, String> getPackages() throws VulnerabilityException {
        Map<String, String> packages = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            boolean inRequireBlock = false;
            boolean inReplaceBlock = false;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (this.isRequireBlock(line)) {
                    inRequireBlock = true;
                    continue;
                }
                if (this.isReplaceBlock(line)) {
                    inReplaceBlock = true;
                    continue;
                }
                if (line.startsWith(")")) {
                    inRequireBlock = false;
                    inReplaceBlock = false;
                    continue;
                }
                if (inRequireBlock) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        String path = parts[0];
                        String version = parts[1];
                        packages.put(path, version);
                    }
                    continue;
                }
                if (this.isInlineRequire(line)) {
                    String[] parts = line.split("\\s+");
                    String path = parts[1];
                    String version = parts[2];
                    packages.put(path, version);
                    continue;
                }
                if (inReplaceBlock) {
                    String[] parts = line.split("\\s+");
                    if (parts.length == 5) {
                        packages.remove(parts[0]);
                        packages.put(parts[3], parts[4]);
                    }
                    continue;
                }
                if (this.isInlineReplace(line)) {
                    String[] parts = line.split("\\s+");
                    packages.remove(parts[1]);
                    packages.put(parts[4], parts[5]);
                    continue;
                }
            }
            reader.close();
        } catch (IOException e) {
            throw new VulnerabilityException("Failed to read go.mod file", e);
        }
        return packages;
    }

    @Override
    public boolean exists() {
        return this.file.exists();
    }
    
    private boolean isRequireBlock(String line) {
        String[] parts = line.split("\\s+");
        return line.startsWith("require(") || 
                (line.startsWith("require") && parts.length == 2);
    }

    private boolean isInlineRequire(String line) {
        String[] parts = line.split("\\s+");
        return line.startsWith("require ") && parts.length == 3;
    }

    private boolean isReplaceBlock(String line) {
        String[] parts = line.split("\\s+");
        return line.startsWith("replace(") || 
                (line.startsWith("replace") && parts.length == 2);
    }

    private boolean isInlineReplace(String line) {
        String[] parts = line.split("\\s+");
        return line.startsWith("replace ") && parts.length == 6;
    }
}
